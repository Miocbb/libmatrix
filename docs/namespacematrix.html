<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Matrix library: matrix Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Matrix library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacematrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">matrix Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>top-level matrix namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacematrix_1_1exception"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix_1_1exception.html">exception</a></td></tr>
<tr class="memdesc:namespacematrix_1_1exception"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top-level exception namespace for matrix library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmatrix_1_1Matrix.html" title="Matrix class declaration. ">Matrix</a> class declaration.  <a href="classmatrix_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1MatrixCommaInitializer.html">MatrixCommaInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used to do comma initialization for <a class="el" href="classmatrix_1_1Matrix.html" title="Matrix class declaration. ">matrix::Matrix</a> object like Eigen library.  <a href="classmatrix_1_1MatrixCommaInitializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a17cd51d578632c666c7bbced84484969"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a17cd51d578632c666c7bbced84484969">mult_dgemm</a> (const double alpha, const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A, const string &amp;op_A, const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;B, const string &amp;op_B, const double beta, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;C)</td></tr>
<tr class="memdesc:a17cd51d578632c666c7bbced84484969"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper of blas <code>dgemm</code> function for general matrix multiplication.  <a href="#a17cd51d578632c666c7bbced84484969">More...</a><br /></td></tr>
<tr class="separator:a17cd51d578632c666c7bbced84484969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18c5fff50904a6261004267fc79e1f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#aa18c5fff50904a6261004267fc79e1f4">mult_dgemm_ABAT</a> (const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;C)</td></tr>
<tr class="memdesc:aa18c5fff50904a6261004267fc79e1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenient function wrapper for three general matrix multiplication.  <a href="#aa18c5fff50904a6261004267fc79e1f4">More...</a><br /></td></tr>
<tr class="separator:aa18c5fff50904a6261004267fc79e1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f458d8ca3574238b1561ba6a97d86d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a89f458d8ca3574238b1561ba6a97d86d">mult_dgemm_ATBA</a> (const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;C)</td></tr>
<tr class="memdesc:a89f458d8ca3574238b1561ba6a97d86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenient function wrapper for three general matrix multiplication.  <a href="#a89f458d8ca3574238b1561ba6a97d86d">More...</a><br /></td></tr>
<tr class="separator:a89f458d8ca3574238b1561ba6a97d86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6a08c0e2be1875832a8e7f93531cf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a2d6a08c0e2be1875832a8e7f93531cf1">mult_dscal</a> (const double alpha, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a2d6a08c0e2be1875832a8e7f93531cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper of blas dscal function to scale matrix by a constant.  <a href="#a2d6a08c0e2be1875832a8e7f93531cf1">More...</a><br /></td></tr>
<tr class="separator:a2d6a08c0e2be1875832a8e7f93531cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1f732c4afd83ab7a472a8575ee7ecf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#acf1f732c4afd83ab7a472a8575ee7ecf">mult_dscal_to</a> (const double alpha, const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:acf1f732c4afd83ab7a472a8575ee7ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">scale a matrix to another matrix by a constant.  <a href="#acf1f732c4afd83ab7a472a8575ee7ecf">More...</a><br /></td></tr>
<tr class="separator:acf1f732c4afd83ab7a472a8575ee7ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b14f684b078a1e766527712fb8153cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a4b14f684b078a1e766527712fb8153cb">set_matrix_random_orthogonal</a> (<a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A, bool using_fixed_seed=true)</td></tr>
<tr class="memdesc:a4b14f684b078a1e766527712fb8153cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input matrix be an random orthogonal matrix.  <a href="#a4b14f684b078a1e766527712fb8153cb">More...</a><br /></td></tr>
<tr class="separator:a4b14f684b078a1e766527712fb8153cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab92bd64ae632bf3f3f67b676c8f423"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a8ab92bd64ae632bf3f3f67b676c8f423">diagonalize_sym_matrix_dsyev</a> (const string &amp;uplo, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A, vector&lt; double &gt; &amp;eig)</td></tr>
<tr class="memdesc:a8ab92bd64ae632bf3f3f67b676c8f423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of lapack <code>dsyev</code> function to diagonalize a symmetric matrix.  <a href="#a8ab92bd64ae632bf3f3f67b676c8f423">More...</a><br /></td></tr>
<tr class="separator:a8ab92bd64ae632bf3f3f67b676c8f423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6084617c3ec268a016d7a9fd2f23989d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a6084617c3ec268a016d7a9fd2f23989d">invert_gen_matrix_dgetri</a> (<a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a6084617c3ec268a016d7a9fd2f23989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a general matrix based on lapack <code>dgetri</code>, which is based on LU factorization computed by lapack <code>dgetrf</code>.  <a href="#a6084617c3ec268a016d7a9fd2f23989d">More...</a><br /></td></tr>
<tr class="separator:a6084617c3ec268a016d7a9fd2f23989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a59e0bbb16518d9f87319cbfcafab6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a9a59e0bbb16518d9f87319cbfcafab6b">invert_spd_matrix_dpotri</a> (const string &amp;uplo, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a9a59e0bbb16518d9f87319cbfcafab6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a real symmetric positive definite (spd) matrix by lapack <code>dpotri</code>, which is based on Cholesky factorization computed by lapack <code>dpotrf</code>.  <a href="#a9a59e0bbb16518d9f87319cbfcafab6b">More...</a><br /></td></tr>
<tr class="separator:a9a59e0bbb16518d9f87319cbfcafab6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5315aae793e6b89f2d22d877eda9935"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#aa5315aae793e6b89f2d22d877eda9935">invert_sym_matrix_dsytri</a> (const string &amp;uplo, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:aa5315aae793e6b89f2d22d877eda9935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a real symmetric indefinite matrix by lapack <code>dsytri</code>, which is based on factorization A = U*D*U**T or A = L*D*L**T computed by lapack <code>dsytrf</code>.  <a href="#aa5315aae793e6b89f2d22d877eda9935">More...</a><br /></td></tr>
<tr class="separator:aa5315aae793e6b89f2d22d877eda9935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eea0f771659ba4104690b17e771f5ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a6eea0f771659ba4104690b17e771f5ad">invert_sym_matrix_dsytri_rook</a> (const string &amp;uplo, <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a6eea0f771659ba4104690b17e771f5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a real symmetric indefinite matrix by lapack <code>dsytri_rook</code>, which is based on factorization A = U*D*U**T or A = L*D*L**T computed by lapack <code>dsytrf_rook</code>.  <a href="#a6eea0f771659ba4104690b17e771f5ad">More...</a><br /></td></tr>
<tr class="separator:a6eea0f771659ba4104690b17e771f5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645299e2ab5ac9836cd8e27b40668376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a645299e2ab5ac9836cd8e27b40668376">write_matrices_to_binary</a> (vector&lt; std::shared_ptr&lt; const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt;&gt; &amp;Mat, const char *fname)</td></tr>
<tr class="memdesc:a645299e2ab5ac9836cd8e27b40668376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a number of matrix into binary file in order.  <a href="#a645299e2ab5ac9836cd8e27b40668376">More...</a><br /></td></tr>
<tr class="separator:a645299e2ab5ac9836cd8e27b40668376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdc0181ff3a8588937fcd5ec59d405a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a1fdc0181ff3a8588937fcd5ec59d405a">read_matrices_from_binary</a> (vector&lt; std::shared_ptr&lt; <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt;&gt; &amp;Mat, const char *fname)</td></tr>
<tr class="memdesc:a1fdc0181ff3a8588937fcd5ec59d405a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a number of matrix into binary file in order.  <a href="#a1fdc0181ff3a8588937fcd5ec59d405a">More...</a><br /></td></tr>
<tr class="separator:a1fdc0181ff3a8588937fcd5ec59d405a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec91deb9474d6aa87d2398197a90ebc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#adec91deb9474d6aa87d2398197a90ebc">read_matrices_from_binary</a> (const char *fname)</td></tr>
<tr class="memdesc:adec91deb9474d6aa87d2398197a90ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read matrix/matrices from binary file and create a vector of matrices.  <a href="#adec91deb9474d6aa87d2398197a90ebc">More...</a><br /></td></tr>
<tr class="separator:adec91deb9474d6aa87d2398197a90ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1e64200c203e8734e1b165b9d85354"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a9a1e64200c203e8734e1b165b9d85354">read_matrices_from_binary</a> (string &amp;fname)</td></tr>
<tr class="memdesc:a9a1e64200c203e8734e1b165b9d85354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read matrix/matrices from binary file and create a vector of matrices.  <a href="#a9a1e64200c203e8734e1b165b9d85354">More...</a><br /></td></tr>
<tr class="separator:a9a1e64200c203e8734e1b165b9d85354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cf49edd3f45fe985f100923e90a827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a79cf49edd3f45fe985f100923e90a827">write_matrices_to_txt</a> (vector&lt; std::shared_ptr&lt; <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt;&gt; &amp;Mat, const string &amp;fname, size_t num_per_line=5)</td></tr>
<tr class="memdesc:a79cf49edd3f45fe985f100923e90a827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a vector of matrices into a txt file.  <a href="#a79cf49edd3f45fe985f100923e90a827">More...</a><br /></td></tr>
<tr class="separator:a79cf49edd3f45fe985f100923e90a827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3fcd36c366d396608b39d484302df0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematrix.html#a6d3fcd36c366d396608b39d484302df0">read_matrices_from_txt</a> (const string &amp;fname)</td></tr>
<tr class="memdesc:a6d3fcd36c366d396608b39d484302df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a vector of matrices from a txt file generated from <a class="el" href="namespacematrix.html#a79cf49edd3f45fe985f100923e90a827" title="Write a vector of matrices into a txt file. ">matrix::write_matrices_to_txt()</a>.  <a href="#a6d3fcd36c366d396608b39d484302df0">More...</a><br /></td></tr>
<tr class="separator:a6d3fcd36c366d396608b39d484302df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>top-level matrix namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8ab92bd64ae632bf3f3f67b676c8f423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::diagonalize_sym_matrix_dsyev </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper of lapack <code>dsyev</code> function to diagonalize a symmetric matrix. </p>
<dl class="section user"><dt>Purpose</dt><dd>Calculate A = Q^T * D * Q, where D is a diagonal matrix, and Q is an orthonormal matrix.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>"U": only the upper triangular will be refereed.<br />
"L": only the lower triangular will be refereed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The matrix to be diagonalized. On exit, the matrix stores the orthonormal eigenvalues matrix Q. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eig</td><td>The eigenvalues in ascending order when succeed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: 0 for success, and others for failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On successful exit, matrix <code>A</code> stores the eigenvalues matrix Q, that is each eigenvector stores continuously in memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a6084617c3ec268a016d7a9fd2f23989d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::invert_gen_matrix_dgetri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a general matrix based on lapack <code>dgetri</code>, which is based on LU factorization computed by lapack <code>dgetrf</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The input general matrix. On exit, if succeed, it stores the inverse of the original matrix A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: 0 for success, and others for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a59e0bbb16518d9f87319cbfcafab6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::invert_spd_matrix_dpotri </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a real symmetric positive definite (spd) matrix by lapack <code>dpotri</code>, which is based on Cholesky factorization computed by lapack <code>dpotrf</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>"U": only the upper triangular will be refereed.<br />
 "L": only the lower triangular will be refereed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The input spd matrix. On exit, if succeed, it stores the inverse of the original matrix A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: 0 for success, and others for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5315aae793e6b89f2d22d877eda9935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::invert_sym_matrix_dsytri </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a real symmetric indefinite matrix by lapack <code>dsytri</code>, which is based on factorization A = U*D*U**T or A = L*D*L**T computed by lapack <code>dsytrf</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>"U": only the upper triangular will be refereed.<br />
"L": only the lower triangular will be refereed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The input spd matrix. On exit, if succeed, it stores the inverse of the original matrix A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: 0 for success, and others for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eea0f771659ba4104690b17e771f5ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::invert_sym_matrix_dsytri_rook </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a real symmetric indefinite matrix by lapack <code>dsytri_rook</code>, which is based on factorization A = U*D*U**T or A = L*D*L**T computed by lapack <code>dsytrf_rook</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>"U": only the upper triangular will be refereed.<br />
"L": only the lower triangular will be refereed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The input matrix. On exit, if succeed, it stores the inverse of the original matrix A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: 0 for success, and others for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a17cd51d578632c666c7bbced84484969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::mult_dgemm </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>op_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>op_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wrapper of blas <code>dgemm</code> function for general matrix multiplication. </p>
<dl class="section user"><dt>Purpose</dt><dd>calculate C = alpha * op(A) * op(B) + beta * C.<br />
op(A) represents the matrix with an operation acted on it.<br />
op(A) = A or op(A) = A^T.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>scalar coefficient on op(A) * op(B). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix view that represents op(A). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_A</td><td>operation acting on matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>matrix view that represents op(B). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_B</td><td>operation acting on matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>scalar coefficient on matrix C. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>matrix C. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa18c5fff50904a6261004267fc79e1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::mult_dgemm_ABAT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenient function wrapper for three general matrix multiplication. </p>
<dl class="section user"><dt>Purpose</dt><dd>calculate C = A * B * A^T.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>matrix C. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89f458d8ca3574238b1561ba6a97d86d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::mult_dgemm_ATBA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenient function wrapper for three general matrix multiplication. </p>
<dl class="section user"><dt>Purpose</dt><dd>calculate C = A^T * B * A.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>matrix C. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d6a08c0e2be1875832a8e7f93531cf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::mult_dscal </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wrapper of blas dscal function to scale matrix by a constant. </p>
<dl class="section user"><dt>Purpose</dt><dd>calculate A = alpha * A</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>the scalar coefficient. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>the matrix to be scaled. On exit, matrix A is updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 for success others for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="acf1f732c4afd83ab7a472a8575ee7ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::mult_dscal_to </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scale a matrix to another matrix by a constant. </p>
<dl class="section user"><dt>Purpose</dt><dd>calculate B = alpha * A</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>the scalar coefficient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the matrix use for scaling. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>On exit, matrix B is overwritten and stores the scaled matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 for success others for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdc0181ff3a8588937fcd5ec59d405a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::read_matrices_from_binary </td>
          <td>(</td>
          <td class="paramtype">vector&lt; std::shared_ptr&lt; <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a number of matrix into binary file in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mat</td><td>a vector matrices to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>the binary file name (relative/absolute path). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adec91deb9474d6aa87d2398197a90ebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classmatrix_1_1Matrix.html">Matrix</a>&gt; &gt; matrix::read_matrices_from_binary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read matrix/matrices from binary file and create a vector of matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>binary file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::shared_ptr&lt;Matrix&gt;&gt;: a vector of matrices. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a1e64200c203e8734e1b165b9d85354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classmatrix_1_1Matrix.html">Matrix</a>&gt; &gt; matrix::read_matrices_from_binary </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read matrix/matrices from binary file and create a vector of matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>binary file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::shared_ptr&lt;Matrix&gt;&gt;: a vector of matrices. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d3fcd36c366d396608b39d484302df0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classmatrix_1_1Matrix.html">Matrix</a>&gt; &gt; matrix::read_matrices_from_txt </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a vector of matrices from a txt file generated from <a class="el" href="namespacematrix.html#a79cf49edd3f45fe985f100923e90a827" title="Write a vector of matrices into a txt file. ">matrix::write_matrices_to_txt()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>the name (relative or absolute path) of the matrix txt file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::shared_ptr&lt;Matrix&gt;&gt;: a vector of matrices. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacematrix.html#a79cf49edd3f45fe985f100923e90a827" title="Write a vector of matrices into a txt file. ">matrix::write_matrices_to_txt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b14f684b078a1e766527712fb8153cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matrix::set_matrix_random_orthogonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>using_fixed_seed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the input matrix be an random orthogonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>The input matrix. On exit, it stores a random orthogonal matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">using_fixed_seed</td><td>If or not using the fixed seed to feed the random number generator. If it is true, the function behavior can be repeatble at different running time, otherwise, it will not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: 0 for success, and others for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a645299e2ab5ac9836cd8e27b40668376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::write_matrices_to_binary </td>
          <td>(</td>
          <td class="paramtype">vector&lt; std::shared_ptr&lt; const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a number of matrix into binary file in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mat</td><td>a vector matrices to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>the binary file name (relative/absolute path). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79cf49edd3f45fe985f100923e90a827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::write_matrices_to_txt </td>
          <td>(</td>
          <td class="paramtype">vector&lt; std::shared_ptr&lt; <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_per_line</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a vector of matrices into a txt file. </p>
<p>The matrices are write in order. For each matrix, the format is the following. The first line constaints the number of row and columns of the matrix. This line is garranted to be the format `printf("Dimension,%zu,%zu\n", row, col) and it is used to indicate the separation of different matrices. The following multiples lines contains all the matrix elements. Each matrix elements are comma-separated. The matrix elements are written in column-wise order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mat</td><td>The set of input matrices to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>The name of the output txt file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_per_line</td><td>number of matrix elements per line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacematrix.html">matrix</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
