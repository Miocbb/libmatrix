<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Matrix library: matrix::Matrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Matrix library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmatrix_1_1Matrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmatrix_1_1Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">matrix::Matrix Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmatrix_1_1Matrix.html" title="Matrix class declaration. ">Matrix</a> class declaration.  
 <a href="classmatrix_1_1Matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="details_2matrix_8h_source.html">matrix.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af0e5cb9a08240d0a27859724439c7958"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958">CopyType</a> { <a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958adb65dd15fe1ca81156e4bb7c9ad887a3">kShallowCopy</a>, 
<a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958aea66d7e5c5a28c08c3d9da566abef2c5">kDeepCopy</a>
 }<tr class="memdesc:af0e5cb9a08240d0a27859724439c7958"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy types.  <a href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af0e5cb9a08240d0a27859724439c7958"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f7969dc3765b253059b423f1c050ae2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a2f7969dc3765b253059b423f1c050ae2">Matrix</a> (size_t <a class="el" href="classmatrix_1_1Matrix.html#a890d838437caf2cd2d2c8c76faad6348">row</a>, size_t <a class="el" href="classmatrix_1_1Matrix.html#abad4fe1787b83e14270d84624bb2eddf">col</a>)</td></tr>
<tr class="memdesc:a2f7969dc3765b253059b423f1c050ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix with given size.  <a href="#a2f7969dc3765b253059b423f1c050ae2">More...</a><br /></td></tr>
<tr class="separator:a2f7969dc3765b253059b423f1c050ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1638a534d410d4ab54504c87c9d7a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#aaa1638a534d410d4ab54504c87c9d7a2">Matrix</a> (size_t <a class="el" href="classmatrix_1_1Matrix.html#a890d838437caf2cd2d2c8c76faad6348">row</a>, size_t <a class="el" href="classmatrix_1_1Matrix.html#abad4fe1787b83e14270d84624bb2eddf">col</a>, vector&lt; double &gt; &amp;inp_data, <a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958">CopyType</a> copy_type=<a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958aea66d7e5c5a28c08c3d9da566abef2c5">kDeepCopy</a>)</td></tr>
<tr class="memdesc:aaa1638a534d410d4ab54504c87c9d7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix from a std::vector&lt;double&gt;.  <a href="#aaa1638a534d410d4ab54504c87c9d7a2">More...</a><br /></td></tr>
<tr class="separator:aaa1638a534d410d4ab54504c87c9d7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14998de43814f8ce1e3be27c02600a57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a14998de43814f8ce1e3be27c02600a57">Matrix</a> (size_t <a class="el" href="classmatrix_1_1Matrix.html#a890d838437caf2cd2d2c8c76faad6348">row</a>, size_t <a class="el" href="classmatrix_1_1Matrix.html#abad4fe1787b83e14270d84624bb2eddf">col</a>, double *inp_data_ptr, <a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958">CopyType</a> copy_type=<a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958aea66d7e5c5a28c08c3d9da566abef2c5">kDeepCopy</a>)</td></tr>
<tr class="memdesc:a14998de43814f8ce1e3be27c02600a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix from a double array pointer.  <a href="#a14998de43814f8ce1e3be27c02600a57">More...</a><br /></td></tr>
<tr class="separator:a14998de43814f8ce1e3be27c02600a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb9652eff8e97620ba9cdca42b273e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#aabbb9652eff8e97620ba9cdca42b273e">Matrix</a> ()</td></tr>
<tr class="memdesc:aabbb9652eff8e97620ba9cdca42b273e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#aabbb9652eff8e97620ba9cdca42b273e">More...</a><br /></td></tr>
<tr class="separator:aabbb9652eff8e97620ba9cdca42b273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83820e226f3b35ca7fb96ac47f89bc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#af83820e226f3b35ca7fb96ac47f89bc8">Matrix</a> (const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;other)</td></tr>
<tr class="memdesc:af83820e226f3b35ca7fb96ac47f89bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy from a matrix.  <a href="#af83820e226f3b35ca7fb96ac47f89bc8">More...</a><br /></td></tr>
<tr class="separator:af83820e226f3b35ca7fb96ac47f89bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930b05119a5322af98cdf45f17558db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a930b05119a5322af98cdf45f17558db9">operator=</a> (const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;other)</td></tr>
<tr class="memdesc:a930b05119a5322af98cdf45f17558db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator: assign from a matrix.  <a href="#a930b05119a5322af98cdf45f17558db9">More...</a><br /></td></tr>
<tr class="separator:a930b05119a5322af98cdf45f17558db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af509d0db3cb2104760254ca8b4f38baa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#af509d0db3cb2104760254ca8b4f38baa">operator=</a> (std::initializer_list&lt; double &gt; init_list)</td></tr>
<tr class="memdesc:af509d0db3cb2104760254ca8b4f38baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator: enable an easy way to do matrix element assignment from std::initializer_list.  <a href="#af509d0db3cb2104760254ca8b4f38baa">More...</a><br /></td></tr>
<tr class="separator:af509d0db3cb2104760254ca8b4f38baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4636ff277c09ac89de81ed233130f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmatrix_1_1MatrixCommaInitializer.html">MatrixCommaInitializer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#ab4636ff277c09ac89de81ed233130f92">operator&lt;&lt;</a> (double a)</td></tr>
<tr class="memdesc:ab4636ff277c09ac89de81ed233130f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator &lt;&lt; overloading for comma initialization like Eigen3 library.  <a href="#ab4636ff277c09ac89de81ed233130f92">More...</a><br /></td></tr>
<tr class="separator:ab4636ff277c09ac89de81ed233130f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9992a2e35eb88295716aa58a1373e6"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#aed9992a2e35eb88295716aa58a1373e6">operator()</a> (size_t i, size_t j)</td></tr>
<tr class="memdesc:aed9992a2e35eb88295716aa58a1373e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access/modify the matrix element by index without bound check.  <a href="#aed9992a2e35eb88295716aa58a1373e6">More...</a><br /></td></tr>
<tr class="separator:aed9992a2e35eb88295716aa58a1373e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec082f053e7369609c6680fccc844f46"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#aec082f053e7369609c6680fccc844f46">operator()</a> (size_t i, size_t j) const </td></tr>
<tr class="memdesc:aec082f053e7369609c6680fccc844f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the matrix element by index without bound check.  <a href="#aec082f053e7369609c6680fccc844f46">More...</a><br /></td></tr>
<tr class="separator:aec082f053e7369609c6680fccc844f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acc718757697cff01ed55bbb751f983"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a5acc718757697cff01ed55bbb751f983">at</a> (size_t i, size_t j)</td></tr>
<tr class="memdesc:a5acc718757697cff01ed55bbb751f983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access/modify the matrix element by index with bound check.  <a href="#a5acc718757697cff01ed55bbb751f983">More...</a><br /></td></tr>
<tr class="separator:a5acc718757697cff01ed55bbb751f983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09539588e7c75ee84ae4750ddf7bc927"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a09539588e7c75ee84ae4750ddf7bc927">at</a> (size_t i, size_t j) const </td></tr>
<tr class="memdesc:a09539588e7c75ee84ae4750ddf7bc927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the matrix element by index with bound check.  <a href="#a09539588e7c75ee84ae4750ddf7bc927">More...</a><br /></td></tr>
<tr class="separator:a09539588e7c75ee84ae4750ddf7bc927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a69827203e2dd27f5076ac2d482deef"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a4a69827203e2dd27f5076ac2d482deef">data</a> ()</td></tr>
<tr class="memdesc:a4a69827203e2dd27f5076ac2d482deef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer that points to the begining of matrix data.  <a href="#a4a69827203e2dd27f5076ac2d482deef">More...</a><br /></td></tr>
<tr class="separator:a4a69827203e2dd27f5076ac2d482deef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f9882e9977d9d0c59a7aa9f5f0f16"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a149f9882e9977d9d0c59a7aa9f5f0f16">data</a> () const </td></tr>
<tr class="memdesc:a149f9882e9977d9d0c59a7aa9f5f0f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the const pointer that points to the begining of matrix data.  <a href="#a149f9882e9977d9d0c59a7aa9f5f0f16">More...</a><br /></td></tr>
<tr class="separator:a149f9882e9977d9d0c59a7aa9f5f0f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890d838437caf2cd2d2c8c76faad6348"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a890d838437caf2cd2d2c8c76faad6348">row</a> () const </td></tr>
<tr class="memdesc:a890d838437caf2cd2d2c8c76faad6348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get matrix row numbers.  <a href="#a890d838437caf2cd2d2c8c76faad6348">More...</a><br /></td></tr>
<tr class="separator:a890d838437caf2cd2d2c8c76faad6348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad4fe1787b83e14270d84624bb2eddf"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#abad4fe1787b83e14270d84624bb2eddf">col</a> () const </td></tr>
<tr class="memdesc:abad4fe1787b83e14270d84624bb2eddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get matrix column numbers.  <a href="#abad4fe1787b83e14270d84624bb2eddf">More...</a><br /></td></tr>
<tr class="separator:abad4fe1787b83e14270d84624bb2eddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bc9d7919a6443b749586d59bff9831"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#ac8bc9d7919a6443b749586d59bff9831">size</a> () const </td></tr>
<tr class="memdesc:ac8bc9d7919a6443b749586d59bff9831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get matrix size, that is, the total number of matrix elements.  <a href="#ac8bc9d7919a6443b749586d59bff9831">More...</a><br /></td></tr>
<tr class="separator:ac8bc9d7919a6443b749586d59bff9831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1c1aad3ad8c736aca85f1a398f478c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#afc1c1aad3ad8c736aca85f1a398f478c">is_data_stored_outside</a> () const </td></tr>
<tr class="memdesc:afc1c1aad3ad8c736aca85f1a398f478c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the matrix data is managed by the object.  <a href="#afc1c1aad3ad8c736aca85f1a398f478c">More...</a><br /></td></tr>
<tr class="separator:afc1c1aad3ad8c736aca85f1a398f478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4e6bc98db2d9a5892afacd8ace671a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a0c4e6bc98db2d9a5892afacd8ace671a">is_square</a> () const </td></tr>
<tr class="memdesc:a0c4e6bc98db2d9a5892afacd8ace671a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the matrix is square or not.  <a href="#a0c4e6bc98db2d9a5892afacd8ace671a">More...</a><br /></td></tr>
<tr class="separator:a0c4e6bc98db2d9a5892afacd8ace671a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed00df042b540f05a797e871c0039c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a6ed00df042b540f05a797e871c0039c9">is_symmetric</a> (double threshold=1e-10) const </td></tr>
<tr class="memdesc:a6ed00df042b540f05a797e871c0039c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current matrix is symmetric or not based on the input threshold.  <a href="#a6ed00df042b540f05a797e871c0039c9">More...</a><br /></td></tr>
<tr class="separator:a6ed00df042b540f05a797e871c0039c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541d488d81babde8a19b0c1eca22e2f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a541d488d81babde8a19b0c1eca22e2f1">is_diagonal</a> (double threshold=1e-10) const </td></tr>
<tr class="memdesc:a541d488d81babde8a19b0c1eca22e2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current matrix is a diagonal matrix or not based on input threshold.  <a href="#a541d488d81babde8a19b0c1eca22e2f1">More...</a><br /></td></tr>
<tr class="separator:a541d488d81babde8a19b0c1eca22e2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec4122e87bd10216f275b1ce53b17a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a3ec4122e87bd10216f275b1ce53b17a5">is_identity</a> (double threshold=1e-10) const </td></tr>
<tr class="memdesc:a3ec4122e87bd10216f275b1ce53b17a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current matrix is identity or not based on input threshold.  <a href="#a3ec4122e87bd10216f275b1ce53b17a5">More...</a><br /></td></tr>
<tr class="separator:a3ec4122e87bd10216f275b1ce53b17a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed81add03db5798d76d40015dfb83c80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#aed81add03db5798d76d40015dfb83c80">is_zeros</a> (double threshold=1e-10) const </td></tr>
<tr class="memdesc:aed81add03db5798d76d40015dfb83c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current matrix is a zero matrix or not based on input threshold.  <a href="#aed81add03db5798d76d40015dfb83c80">More...</a><br /></td></tr>
<tr class="separator:aed81add03db5798d76d40015dfb83c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20247f5f21f67aa5095ad72509c5742c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a20247f5f21f67aa5095ad72509c5742c">is_equal_to</a> (const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;other, double threshold=1e-10) const </td></tr>
<tr class="memdesc:a20247f5f21f67aa5095ad72509c5742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two matrix is equal by scanning everything based on a threshold.  <a href="#a20247f5f21f67aa5095ad72509c5742c">More...</a><br /></td></tr>
<tr class="separator:a20247f5f21f67aa5095ad72509c5742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19a57b732cf973d74a033f4d6156655"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#ac19a57b732cf973d74a033f4d6156655">is_same_dimension_to</a> (const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;other) const </td></tr>
<tr class="memdesc:ac19a57b732cf973d74a033f4d6156655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two matrix has the same dimension.  <a href="#ac19a57b732cf973d74a033f4d6156655">More...</a><br /></td></tr>
<tr class="separator:ac19a57b732cf973d74a033f4d6156655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca6cc4a09046b9b8be02f98cc3d3d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a1ca6cc4a09046b9b8be02f98cc3d3d20">show_full</a> (size_t elements_per_line=5) const </td></tr>
<tr class="memdesc:a1ca6cc4a09046b9b8be02f98cc3d3d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">print out the full matrix.  <a href="#a1ca6cc4a09046b9b8be02f98cc3d3d20">More...</a><br /></td></tr>
<tr class="separator:a1ca6cc4a09046b9b8be02f98cc3d3d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e423437c09cbf733c0e9d57caf4855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a69e423437c09cbf733c0e9d57caf4855">show_lower</a> (size_t elements_per_line=5) const </td></tr>
<tr class="memdesc:a69e423437c09cbf733c0e9d57caf4855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the lower triangular matrix (including diagonal elements).  <a href="#a69e423437c09cbf733c0e9d57caf4855">More...</a><br /></td></tr>
<tr class="separator:a69e423437c09cbf733c0e9d57caf4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c80fc7002763f2cc9cc344af5366d0e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a6c80fc7002763f2cc9cc344af5366d0e">trace</a> () const </td></tr>
<tr class="memdesc:a6c80fc7002763f2cc9cc344af5366d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate matrix trace.  <a href="#a6c80fc7002763f2cc9cc344af5366d0e">More...</a><br /></td></tr>
<tr class="separator:a6c80fc7002763f2cc9cc344af5366d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a381550e666d171d49a5570146da63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a38a381550e666d171d49a5570146da63">resize</a> (size_t <a class="el" href="classmatrix_1_1Matrix.html#a890d838437caf2cd2d2c8c76faad6348">row</a>, size_t <a class="el" href="classmatrix_1_1Matrix.html#abad4fe1787b83e14270d84624bb2eddf">col</a>)</td></tr>
<tr class="memdesc:a38a381550e666d171d49a5570146da63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the matrix into given dimension.  <a href="#a38a381550e666d171d49a5570146da63">More...</a><br /></td></tr>
<tr class="separator:a38a381550e666d171d49a5570146da63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79193563b7eb46adb765171b8b4ae045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a79193563b7eb46adb765171b8b4ae045">to_symmetric</a> (const string &amp;uplo)</td></tr>
<tr class="memdesc:a79193563b7eb46adb765171b8b4ae045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the matrix to be symmetric.  <a href="#a79193563b7eb46adb765171b8b4ae045">More...</a><br /></td></tr>
<tr class="separator:a79193563b7eb46adb765171b8b4ae045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76857555cc727fb18705723edcd7cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#ac76857555cc727fb18705723edcd7cbf">randomize</a> (double a, double b)</td></tr>
<tr class="memdesc:ac76857555cc727fb18705723edcd7cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the matrix to be random with elements uniformly distributed in range [a, b).  <a href="#ac76857555cc727fb18705723edcd7cbf">More...</a><br /></td></tr>
<tr class="separator:ac76857555cc727fb18705723edcd7cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9309271d3f14887e87bfd9dbec9a7aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#ab9309271d3f14887e87bfd9dbec9a7aa">randomize_seed_fixed</a> (double a, double b)</td></tr>
<tr class="memdesc:ab9309271d3f14887e87bfd9dbec9a7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the matrix to be random with elements uniformly distributed in range [a, b).  <a href="#ab9309271d3f14887e87bfd9dbec9a7aa">More...</a><br /></td></tr>
<tr class="separator:ab9309271d3f14887e87bfd9dbec9a7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826066b50bc816b3b9eafeb7650dec6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a826066b50bc816b3b9eafeb7650dec6c">scale</a> (const double alpha)</td></tr>
<tr class="memdesc:a826066b50bc816b3b9eafeb7650dec6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales current matrix by a constant.  <a href="#a826066b50bc816b3b9eafeb7650dec6c">More...</a><br /></td></tr>
<tr class="separator:a826066b50bc816b3b9eafeb7650dec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64a23a56b942cd06a0dcf265e67e2e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#ae64a23a56b942cd06a0dcf265e67e2e0">fill_all</a> (double a)</td></tr>
<tr class="memdesc:ae64a23a56b942cd06a0dcf265e67e2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill all elements with input number.  <a href="#ae64a23a56b942cd06a0dcf265e67e2e0">More...</a><br /></td></tr>
<tr class="separator:ae64a23a56b942cd06a0dcf265e67e2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f041e8c8c6b012c8ec5c11e6b6370"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa90f041e8c8c6b012c8ec5c11e6b6370"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#aa90f041e8c8c6b012c8ec5c11e6b6370">set_identity</a> ()</td></tr>
<tr class="memdesc:aa90f041e8c8c6b012c8ec5c11e6b6370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix to be identity. <br /></td></tr>
<tr class="separator:aa90f041e8c8c6b012c8ec5c11e6b6370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d14c26095c116b2bbadd9207f19bab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d14c26095c116b2bbadd9207f19bab1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatrix_1_1Matrix.html#a3d14c26095c116b2bbadd9207f19bab1">transpose</a> ()</td></tr>
<tr class="memdesc:a3d14c26095c116b2bbadd9207f19bab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix to be its transpose. <br /></td></tr>
<tr class="separator:a3d14c26095c116b2bbadd9207f19bab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmatrix_1_1Matrix.html" title="Matrix class declaration. ">Matrix</a> class declaration. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="af0e5cb9a08240d0a27859724439c7958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958">matrix::Matrix::CopyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af0e5cb9a08240d0a27859724439c7958adb65dd15fe1ca81156e4bb7c9ad887a3"></a>kShallowCopy&#160;</td><td class="fielddoc">
<p>shallow copy: only gain data access and avoid copying data elements </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af0e5cb9a08240d0a27859724439c7958aea66d7e5c5a28c08c3d9da566abef2c5"></a>kDeepCopy&#160;</td><td class="fielddoc">
<p>deep copy: copy all the data. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2f7969dc3765b253059b423f1c050ae2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix with given size. </p>
<p>The memory for a matrix with input size will be allocated and initialize all matrix elements to be zero. <a class="el" href="classmatrix_1_1Matrix.html" title="Matrix class declaration. ">Matrix</a> data is stored in inside of this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>Number of rows of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>Number of columns of the matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa1638a534d410d4ab54504c87c9d7a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matrix::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958">CopyType</a>&#160;</td>
          <td class="paramname"><em>copy_type</em> = <code><a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958aea66d7e5c5a28c08c3d9da566abef2c5">kDeepCopy</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a matrix from a std::vector&lt;double&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>Number of rows of the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>Number of columns of the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inp_data</td><td>A std::vector&lt;double&gt; that stores the matrix data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_type</td><td>Copy type to initialize the matrix from <code>inp_data</code>. If <code>copy_type</code> equals to <a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958aea66d7e5c5a28c08c3d9da566abef2c5" title="deep copy: copy all the data. ">matrix::Matrix::kDeepCopy</a>, all the data will be copied into matrix. If the <code>copy</code> type equals to <a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958adb65dd15fe1ca81156e4bb7c9ad887a3" title="shallow copy: only gain data access and avoid copying data elements ">matrix::Matrix::kShallowCopy</a>, the pointer to the data memory is assigned to the matrix and the matrix gains the access to the data. Default is deep copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data size of the vector will be check to match the matrix size. </dd>
<dd>
This constructor is not const friendly. If you want to do a shallow copy of a const vector to the matrix, you can do declare the created <a class="el" href="classmatrix_1_1Matrix.html" title="Matrix class declaration. ">Matrix</a> to be const and typecast the const vector to be non-const vector, that is, <div class="fragment"><div class="line"><span class="keyword">const</span> vector&lt;double&gt; <a class="code" href="classmatrix_1_1Matrix.html#a4a69827203e2dd27f5076ac2d482deef">data</a>;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classmatrix_1_1Matrix.html#aabbb9652eff8e97620ba9cdca42b273e">Matrix</a> A(<a class="code" href="classmatrix_1_1Matrix.html#a890d838437caf2cd2d2c8c76faad6348">row</a>, <a class="code" href="classmatrix_1_1Matrix.html#abad4fe1787b83e14270d84624bb2eddf">col</a>, const_cast &lt;vector&lt;double&gt;&gt;(<a class="code" href="classmatrix_1_1Matrix.html#a4a69827203e2dd27f5076ac2d482deef">data</a>),</div><div class="line">               <a class="code" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958adb65dd15fe1ca81156e4bb7c9ad887a3">kShallowCopy</a>);</div></div><!-- fragment --> This can preserve the created matrix not change the original vector data. </dd></dl>

</div>
</div>
<a class="anchor" id="a14998de43814f8ce1e3be27c02600a57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matrix::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>inp_data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958">CopyType</a>&#160;</td>
          <td class="paramname"><em>copy_type</em> = <code><a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958aea66d7e5c5a28c08c3d9da566abef2c5">kDeepCopy</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a matrix from a double array pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp_data_ptr</td><td>a pointer points to double array that stores the matrix data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_type</td><td>If <code>copy_type</code> equals <a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958aea66d7e5c5a28c08c3d9da566abef2c5" title="deep copy: copy all the data. ">matrix::Matrix::kDeepCopy</a>, all the data will be copied into matrix. If the <code>copy_type</code> equals to <a class="el" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958adb65dd15fe1ca81156e4bb7c9ad887a3" title="shallow copy: only gain data access and avoid copying data elements ">matrix::Matrix::kShallowCopy</a>, the pointer <code>inp_data_ptr</code> is stored in the matrix to gain the access to matrix data. Default is deep copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data size of the array will NOT be check to match the matrix size. Use this constructor carefully. </dd>
<dd>
This constructor is not const friendly. If you want to do a shallow copy of a const double array to the matrix, you can do declare the created <a class="el" href="classmatrix_1_1Matrix.html" title="Matrix class declaration. ">Matrix</a> to be const and typecast the const array to be non-const array, that is, <div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> * <a class="code" href="classmatrix_1_1Matrix.html#a4a69827203e2dd27f5076ac2d482deef">data</a>;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classmatrix_1_1Matrix.html#aabbb9652eff8e97620ba9cdca42b273e">Matrix</a> A(<a class="code" href="classmatrix_1_1Matrix.html#a890d838437caf2cd2d2c8c76faad6348">row</a>, <a class="code" href="classmatrix_1_1Matrix.html#abad4fe1787b83e14270d84624bb2eddf">col</a>, const_cast &lt;double *&gt;(data), <a class="code" href="classmatrix_1_1Matrix.html#af0e5cb9a08240d0a27859724439c7958adb65dd15fe1ca81156e4bb7c9ad887a3">kShallowCopy</a>);</div></div><!-- fragment --> This can preserve the created matrix not change the original array data. </dd></dl>

</div>
</div>
<a class="anchor" id="aabbb9652eff8e97620ba9cdca42b273e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matrix::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Create an empty matrix object with dimension [0, 0]. </p>

</div>
</div>
<a class="anchor" id="af83820e226f3b35ca7fb96ac47f89bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matrix::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor: copy from a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the other matrix to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5acc718757697cff01ed55bbb751f983"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; matrix::Matrix::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access/modify the matrix element by index with bound check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The row index of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The column index of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double&amp;: matrix element [<code>i</code>, <code>j</code>]. </dd></dl>

</div>
</div>
<a class="anchor" id="a09539588e7c75ee84ae4750ddf7bc927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; matrix::Matrix::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the matrix element by index with bound check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The row index of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The column index of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const double&amp;: matrix element [<code>i</code>, <code>j</code>]. </dd></dl>

</div>
</div>
<a class="anchor" id="abad4fe1787b83e14270d84624bb2eddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t&amp; matrix::Matrix::col </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get matrix column numbers. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a class="anchor" id="a4a69827203e2dd27f5076ac2d482deef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* matrix::Matrix::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pointer that points to the begining of matrix data. </p>
<dl class="section return"><dt>Returns</dt><dd>double * </dd></dl>

</div>
</div>
<a class="anchor" id="a149f9882e9977d9d0c59a7aa9f5f0f16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double* matrix::Matrix::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the const pointer that points to the begining of matrix data. </p>
<dl class="section return"><dt>Returns</dt><dd>const double * </dd></dl>

</div>
</div>
<a class="anchor" id="ae64a23a56b942cd06a0dcf265e67e2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::Matrix::fill_all </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill all elements with input number. </p>
<p>For all matrix element A(i, i), make A(i, i) = <code>a</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the number to be filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc1c1aad3ad8c736aca85f1a398f478c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool matrix::Matrix::is_data_stored_outside </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the matrix data is managed by the object. </p>
<p>If true, the matrix data will be destroyed along with the object. otherwise, it will not. </p><dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if the matrix is an empty matrix, it will return false. </dd></dl>

</div>
</div>
<a class="anchor" id="a541d488d81babde8a19b0c1eca22e2f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matrix::Matrix::is_diagonal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current matrix is a diagonal matrix or not based on input threshold. </p>
<p>Default threshold is 1e-10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>the threshold of testing equality between two float numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a class="anchor" id="a20247f5f21f67aa5095ad72509c5742c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matrix::Matrix::is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two matrix is equal by scanning everything based on a threshold. </p>
<p>By default, the threshold is 1e-10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the other matrix to be compared with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a3ec4122e87bd10216f275b1ce53b17a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matrix::Matrix::is_identity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current matrix is identity or not based on input threshold. </p>
<p>Default threshold is 1e-10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>the threshold of testing equality between two float numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a class="anchor" id="ac19a57b732cf973d74a033f4d6156655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matrix::Matrix::is_same_dimension_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two matrix has the same dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the other matrix to be compared with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c4e6bc98db2d9a5892afacd8ace671a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool matrix::Matrix::is_square </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the matrix is square or not. </p>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a6ed00df042b540f05a797e871c0039c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matrix::Matrix::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current matrix is symmetric or not based on the input threshold. </p>
<p>Default threshold is 1e-10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>the threshold of testing equality between two float numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a class="anchor" id="aed81add03db5798d76d40015dfb83c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool matrix::Matrix::is_zeros </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-10</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the current matrix is a zero matrix or not based on input threshold. </p>
<p>Default threshold is 1e-10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>the threshold of testing equality between two float numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. </dd></dl>

</div>
</div>
<a class="anchor" id="aed9992a2e35eb88295716aa58a1373e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; matrix::Matrix::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access/modify the matrix element by index without bound check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The row index of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The column index of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double&amp;: matrix element [<code>i</code>, <code>j</code>]. </dd></dl>

</div>
</div>
<a class="anchor" id="aec082f053e7369609c6680fccc844f46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; matrix::Matrix::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the matrix element by index without bound check. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The row index of the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The column index of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const double&amp;: matrix element [<code>i</code>, <code>j</code>]. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4636ff277c09ac89de81ed233130f92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatrix_1_1MatrixCommaInitializer.html">MatrixCommaInitializer</a> matrix::Matrix::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator &lt;&lt; overloading for comma initialization like Eigen3 library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>an element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Initialize matrix object with the help of operator <code>&lt;&lt;</code> and <code>,</code> in an easy way. That is, <div class="fragment"><div class="line"><a class="code" href="classmatrix_1_1Matrix.html#aabbb9652eff8e97620ba9cdca42b273e">Matrix</a> A(2, 2); <span class="comment">// create a matrix with dimension [2, 2] first.</span></div><div class="line">A &lt;&lt; 1, 2,      <span class="comment">// initialization with comma initialization. A(0, 1) = 2,</span></div><div class="line">     3, 4;      <span class="comment">// and A(1, 0) = 3.</span></div><div class="line">A &lt;&lt; 1, 2, 3;   <span class="comment">// Error: will throw an error for unmatched size.</span></div></div><!-- fragment --> The matrix dimension of A has to be specified in advance and the number of elements has to be equal to the matrix size, otherwise, it will throw an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a930b05119a5322af98cdf45f17558db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a>&amp; matrix::Matrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator: assign from a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the other matrix used for assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af509d0db3cb2104760254ca8b4f38baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmatrix_1_1Matrix.html">Matrix</a>&amp; matrix::Matrix::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; double &gt;&#160;</td>
          <td class="paramname"><em>init_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator: enable an easy way to do matrix element assignment from std::initializer_list. </p>
<p>@ param[in] init_list: the data contained in the initializer_list. @ return: the const reference to the matrix itself.</p>
<dl class="section note"><dt>Note</dt><dd>The matrix dimension has to be declared in advance. The input list size will be checked for the initialization. Below is an example, <div class="fragment"><div class="line"><a class="code" href="classmatrix_1_1Matrix.html#aabbb9652eff8e97620ba9cdca42b273e">Matrix</a> A(2, 2); <span class="comment">// create a matrix with dimension [2, 2] first.</span></div><div class="line">A = {1, 2,      <span class="comment">// initialization with initializer_list. A(0, 1) = 2,</span></div><div class="line">     3, 4};     <span class="comment">// and A(1, 0) = 3.</span></div><div class="line">A = {1, 2, 3};  <span class="comment">// Error: will throw an error for unmatched size.</span></div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ac76857555cc727fb18705723edcd7cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::Matrix::randomize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the matrix to be random with elements uniformly distributed in range [a, b). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>left range bound. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>right range bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The random number generator is initialized with a NON-FIXED seed. So the randomness behavior is not repeatable at running time. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9309271d3f14887e87bfd9dbec9a7aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::Matrix::randomize_seed_fixed </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the matrix to be random with elements uniformly distributed in range [a, b). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>left range bound. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>right range bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The random number generator is initialized with a FIXED seed. So the randomness behavior is repeatable at running time. </dd></dl>

</div>
</div>
<a class="anchor" id="a38a381550e666d171d49a5570146da63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::Matrix::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the matrix into given dimension. </p>
<p><a class="el" href="classmatrix_1_1Matrix.html" title="Matrix class declaration. ">Matrix</a> data value is perserved. The order of data stored in memory is preserved as well, so you will need to re-interprate the new matrix based on the new size.</p>
<p>When new matrix size is greater than the original matrix size, zeros will be appended to the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>new number of rows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>new number of columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a890d838437caf2cd2d2c8c76faad6348"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t&amp; matrix::Matrix::row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get matrix row numbers. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a class="anchor" id="a826066b50bc816b3b9eafeb7650dec6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::Matrix::scale </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales current matrix by a constant. </p>
<p>A = alpha * A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>the scalar coefficient. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ca6cc4a09046b9b8be02f98cc3d3d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::Matrix::show_full </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elements_per_line</em> = <code>5</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print out the full matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elements_per_line</td><td>number of elements being printed per line. Default is 5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69e423437c09cbf733c0e9d57caf4855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::Matrix::show_lower </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elements_per_line</em> = <code>5</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the lower triangular matrix (including diagonal elements). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elements_per_line</td><td>number of elements being printed per line. Default is 5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8bc9d7919a6443b749586d59bff9831"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t&amp; matrix::Matrix::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get matrix size, that is, the total number of matrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a class="anchor" id="a79193563b7eb46adb765171b8b4ae045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix::Matrix::to_symmetric </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>uplo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the matrix to be symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>when <code>uplo</code> equals to "U", the upper triangular part is used. when <code>uplo</code> equals to "L", the lower triangular part is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c80fc7002763f2cc9cc344af5366d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matrix::Matrix::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate matrix trace. </p>
<dl class="section return"><dt>Returns</dt><dd>double: the matrix trace. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacematrix.html">matrix</a></li><li class="navelem"><a class="el" href="classmatrix_1_1Matrix.html">Matrix</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
